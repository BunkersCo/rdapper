#!/usr/bin/perl
# Copyright (c) 2012 CentralNic Ltd. All rights reserved. This program is
# free software; you can redistribute it and/or modify it under the same
# terms as Perl itself.
use LWP;
use HTTP::Request::Common;
use JSON;
use Getopt::Long;
use POSIX;
use strict;

my $NAME = 'rdapper';
our $VERSION = '0.02';

#
# determines the order in which fields appear in output. The higher the number,
# the closer to the top the field appears:
#
my $order = {
	'handle'		=> 99999,
	'name'			=> 88888,
	'names'			=> 88887,
	'variants'		=> 77777,
	'status'		=> 66666,
	'sponsoredBy'		=> 66333,
	'registrationDate'	=> 55555,
	'registrationBy'	=> 44444,
	'expirationDate'	=> 33333,
	'lastChangedDate'	=> 22222,
	'lastChangedBy'		=> 11111,
	'transferDate'		=> 11110,
	'entities'		=> 11109,
	'nameServers'		=> 11108,
	'delegationKeys'	=> 11107,
	'postalAddress'		=> 11106,
	'phones'		=> 11105,
	'emails'		=> 11104,
	'keyTag'		=> 11103,
	'algorithm'		=> 11102,
	'digestType'		=> 11101,
	'digest'		=> 11100,
};

#
# English names for keys. These need to be internationalised at some point:
#
my $name = {
	'algorithm'		=> 'Algorithm',
	'country'		=> 'Country',
	'delegationKeys'	=> 'DNSSEC Key',
	'description'		=> 'Description',
	'digest'		=> 'Digest',
	'digestType'		=> 'Digest Type',
	'emails'		=> 'Email Address',
	'endAddress'		=> 'End Address',
	'endAutnum'		=> 'End AS',
	'entities'		=> 'Contact',
	'errorCode'		=> 'Error Code',
	'expirationDate'	=> 'Expiration Date',
	'fax'			=> 'Fax',
	'handle'		=> 'Handle',
	'ipAddresses'		=> 'IP Address',
	'ipVersion'		=> 'IP Version',
	'keyTag'		=> 'Key Tag',
	'lang'			=> 'Language',
	'lastChangedBy'		=> 'Last Changed Up',
	'lastChangedDate'	=> 'Last Changed',
	'links'			=> 'Link',
	'name'			=> 'Name',
	'names'			=> 'Name',
	'nameServers'		=> 'Nameserver',
	'notices'		=> 'Notice',
	'parentHandle'		=> 'Parent',
	'phones'		=> 'Telephone',
	'port43'		=> 'Port 43 Whois',
	'postalAddress'		=> 'Postal Address',
	'rdapConformance'	=> 'RDAP Conformance',
	'registrationBy'	=> 'Registered By',
	'registrationDate'	=> 'Registered',
	'remarks'		=> 'Remarks',
	'resoldBy'		=> 'Resold By',
	'roles'			=> 'Role',
	'sponsoredBy'		=> 'Sponsored By',
	'startAddress'		=> 'Start Address',
	'startAutnum'		=> 'Start AS',
	'status'		=> 'Status',
	'title'			=> 'Title',
	'transferDate'		=> 'Transferred',
	'type'			=> 'Type',
	'variants'		=> 'Variant',
};

#
# handlers for specific data types:
#
my $handler = {
	'delegationKeys'	=> \&handle_delegationKeys,
	'emails'		=> \&handle_emails,
	'entities'		=> \&handle_entities,
	'ipAddresses'		=> \&handle_ipAddresses,
#	'links'			=> \&handle_links,
	'lang'			=> \&handle_language,
	'names'			=> \&handle_names,
	'nameServers'		=> \&handle_nameServers,
	'notices'		=> \&handle_notices,
	'phones'		=> \&handle_phones,
	'postalAddress'		=> \&handle_postalAddress,
#	'remarks',		=> \&handle_remarks,
	'rdapConformance'	=> \&handle_rdapConformance,
	'status'		=> \&handle_status,
#	'variants'		=> \&handle_variants,
};

#
# entity roles:
#
my @roles = qw(registrant admin tech billing);

#
# command line options:
#
my $help;
my $host;
my $type = 'domain';
my $query;
my $raw;
my $tls;
my $lang;
my $encoding;
GetOptions(
	'help'		=> \$help,
	'host=s'	=> \$host,
	'type:s'	=> \$type,
	'query:s'	=> \$query,
	'raw'		=> \$raw,
	'tls'		=> \$tls,
	'lang:s'	=> \$lang,
	'encoding:s'	=> \$encoding,
);
$type = lc($type);
$query = $ARGV[0] if ($query eq '' && $ARGV[0] ne '');

if ($lang eq '') {
	if (defined($ENV{'LANG'})) {
		($lang, $encoding) = split(/\./, $ENV{'LANG'}, 2);
		$lang =~ s/_/-/;

	} else {
		$lang = 'en';

	}
}

$encoding = 'UTF-8' if ($encoding eq '');

help() if ($host eq '' || $query eq '' || $help);

#
# prepare the UA:
#
my $uri = sprintf('%s://%s/%s/%s', ($tls ? 'https' : 'http'), $host, $type, $query);

my $ua = LWP::UserAgent->new;
$ua->agent("$NAME/$VERSION");

#
# prepare request:
#
my $req = GET($uri);
$req->header('Accept-Language',	$lang);
$req->header('Accept-Encoding',	$encoding);
$req->header('Accept',		'application/json');

#
# send request:
#
my $res = $ua->request($req);

# this is used to prepend information to a key name:
my $prefix;

# output rows go in here:
my @rows;

# notices go in here:
my @notices;

#
# handle response:
#
if ($res->is_error) {
	printf(STDERR "Error: %s\n", $res->status_line);
	exit(1);

} elsif ($res->header('Content-Type') ne 'application/rdap+json') {
	printf(STDERR "Don't know what to do with %s\n", $res->header('Content-Type'));
	exit(1);

} else {
	my $json = new JSON;
	my $data = $json->decode($res->content);

	if ($raw) {
		print $json->pretty->encode($data);

	} else {
		handle_generic($data);

	}
}

#
# output response:
#
my $max = 0;
map { $max = length($_->[0]) if (length($_->[0]) > $max) } @rows;

foreach my $row (@rows) {
	print	$row->[0] .
		' ' x ($max -length($row->[0])) .
		' : ' .
		$row->[1] .
		"\n";
}

#
# display notices:
#
foreach my $notice (@notices) {
	my $bar = '=' x (38 - (POSIX::floor(length($notice->{'notice'}->{'title'}))/2));
	print "\n".$bar.' '.$notice->{'notice'}->{'title'}.' '.$bar."\n\n";
	map { print $_."\n" } @{$notice->{'notice'}->{'description'}};
	print "\n";
	print "URI: ".$notice->{'notice'}->{'uri'}."\n" if (defined($notice->{'notice'}->{'uri'}));
}

print "\n";

#
# END:
#
exit(0);

# display help:
sub help {
	print <<"END";
$NAME version $VERSION. Copyright 2012 CentralNic Ltd.
Usage: $NAME --host=HOST [--type=TYPE] QUERY
Options:
  --help                Show this help
  --host=HOST           Set server hostname
  --type=TYPE           Set query type (default: domain)
  --raw			Show raw JSON response
  --tls			Use SSL/TLS
  --lang		Set language (default: taken from \$LANG)
  --encoding		Set encoding (default: taken from \$LANG)
END
	exit;
}

# converts an RDAP key into a human readable name:
sub name {
	my $key = shift;
	return ($name->{$key} || $key);
}

# append a row [$name, $value] to the output array:
sub append_row {
	my $row = shift;
	$row->[0] = $prefix.' '.$row->[0] if ($prefix ne '');
	push(@rows, $row);
}

# handler for generic (top-level) data:
sub handle_generic {
	my ($data, $prefix) = @_;

	foreach my $key (reverse sort { $order->{$a} <=> $order->{$b} } keys(%{$data})) {
		if (defined($handler->{$key})) {
			&{$handler->{$key}}($data->{$key});

		} elsif (ref($data->{$key}) eq '') {
			append_row([name($key), $data->{$key}]);

		} else {
			append_row([name($key), encode_json({$key => $data->{$key}})]);

		}
	}
}

#
# handlers for specific keys:
#

sub handle_delegationKeys {
	my $keys = shift;

	foreach my $key (@{$keys}) {
		$prefix = name('delegationKeys');
		handle_generic($key);
		$prefix = '';
	}
}

sub handle_entities {
	my $entities = shift;

	my $roles = {};
	foreach my $entity (@{$entities}) {
		next if (!defined($entity->{'roles'}));

		foreach my $role (@{$entity->{'roles'}}) {
			$roles->{$role} = $entity;
		}
		delete($entity->{'roles'});
	}

	foreach my $role (@roles) {
		next if (!defined($roles->{$role}));
		$prefix = sprintf('%s Contact', ucfirst($role));
		handle_generic($roles->{$role});
		$prefix = '';
	}
}

sub handle_emails {
	my $addrs = shift;

	foreach my $addrs (@{$addrs}) {
		append_row([$name->{'emails'}, $addrs]);
	}
}

sub handle_ipAddresses {
	my $addrs = shift;

	foreach my $addrs (@{$addrs}) {
		append_row([$name->{'ipAddresses'}, $addrs]);
	}
}

sub handle_language {
	# do nothing
}

sub handle_names {
	my $names = shift;

	append_row([$name->{'names'}, sort(join(', ', grep { $_ ne '' } @{$names}))]);
}

sub handle_nameServers {
	my $ns = shift;

	foreach my $host (sort { $a->{'name'} cmp $b->{'name'} } @{$ns}) {
		append_row([$name->{'nameServers'}, $host->{'name'}]);
	}
}

sub handle_phones {
	my $phones = shift;

	foreach my $type (keys(%{$phones})) {
		if ($type eq 'fax') {
			append_row([$name->{'fax'}, $phones->{$type}]);

		} else {
			append_row([sprintf('%s (%s)', $name->{'phones'}, $type), $phones->{$type}]);

		}
	}
}

sub handle_postalAddress {
	my $address = shift;

	foreach my $line (@{$address}) {
		append_row([$name->{'postalAddress'}, $line]);
	}

}

sub handle_rdapConformance {
	# do nothing
}

sub handle_status {
	my $codes = shift;

	foreach my $code (@{$codes}) {
		append_row([$name->{'status'}, $code]);
	}
}

sub handle_notices {
	my $notices = shift;

	foreach my $notice (@{$notices}) {
		push(@notices, $notice);
	}
}

__END__
=pod

=head1 NAME

rdapper

=head1 DESCRIPTION

rdapper is a command-line client for the Registration Data Access Protocol
(RDAP), the successor protocol to Whois (RFC 3912). RDAP is currently being
developed by the WEIRDS IETF working group, and has not yet been finalized.

This tool will send an RDAP query to an RDAP server over HTTP or HTTPS, parse
the JSON response, and display it in human-readable form.

=head1 USAGE

    rdapper --host=HOST [--type=TYPE] [--tls] [--raw] QUERY

=head1 OPTIONS

=over

=item --host=HOST

Specify the host to query

=item --TYPE=TYPE (default: domain)

Specify the type of object being queried. Possible values are: domain, entity,
nameserver, autnum, ip.

=item --tls

Force use of TLS.

=item --raw

Causes rdapper to emit pretty-printed JSON rather than text output.

=item lang=LANGUAGE

Specify a language. This is sent to the server using the C<Accept-Language>
header. If unset, the language will be taken from your $LANG environment
variable (or "en" if that is not defined).

=item encoding=encoding

Specify an encoding. This is sent to the server using the C<Accept-Encoding>
header. If unset, the encoding will be taken from your $LANG environment
variable (or "UTF-8" if that is not defined).

=back

=head1 SEE ALSO

=over

=item L<http://tools.ietf.org/wg/weirds/>

=item L<https://www.centralnic.com/>

=back

=head1 COPYRIGHT

rdapper is Copyright 2012 CentralNic Ltd. All rights reserved. This program is
free software; you can redistribute it and/or modify it under the same terms as
Perl itself.

=cut